// Auto-generated by bebopc-gen-swift. Do not edit.
// swiftlint:disable all
import SwiftBebop

public struct HelloRequest: BebopRecord, BebopReflectable {
  public let name: String

  enum CodingKeys: String, CodingKey {
    case name
  }

  public init(name: String) {
    self.name = name
  }

  public static func decode(from reader: inout BebopReader) throws -> HelloRequest {
    let name = try reader.readString()
    return HelloRequest(name: name)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeString(name)
  }

  public var encodedSize: Int {
    var size = 0
    size += (4 + name.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "HelloRequest",
    fqn: "HelloRequest",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "name",
          index: 0,
          typeName: "String"
        )
      ]))
  )
}

public struct HelloReply: BebopRecord, BebopReflectable {
  public let greeting: String

  enum CodingKeys: String, CodingKey {
    case greeting
  }

  public init(greeting: String) {
    self.greeting = greeting
  }

  public static func decode(from reader: inout BebopReader) throws -> HelloReply {
    let greeting = try reader.readString()
    return HelloReply(greeting: greeting)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeString(greeting)
  }

  public var encodedSize: Int {
    var size = 0
    size += (4 + greeting.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "HelloReply",
    fqn: "HelloReply",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "greeting",
          index: 0,
          typeName: "String"
        )
      ]))
  )
}

public struct TickRequest: BebopRecord, BebopReflectable {
  public let count: UInt32

  enum CodingKeys: String, CodingKey {
    case count
  }

  public init(count: UInt32) {
    self.count = count
  }

  public static func decode(from reader: inout BebopReader) throws -> TickRequest {
    let count = try reader.readUInt32()
    return TickRequest(count: count)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeUInt32(count)
  }

  public var encodedSize: Int { 4 }

  public static let bebopReflection = BebopTypeReflection(
    name: "TickRequest",
    fqn: "TickRequest",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "count",
          index: 0,
          typeName: "UInt32"
        )
      ]))
  )
}

public struct TickReply: BebopRecord, BebopReflectable {
  public let seq: UInt32

  public let timestamp: String

  enum CodingKeys: String, CodingKey {
    case seq
    case timestamp
  }

  public init(seq: UInt32, timestamp: String) {
    self.seq = seq
    self.timestamp = timestamp
  }

  public static func decode(from reader: inout BebopReader) throws -> TickReply {
    let seq = try reader.readUInt32()
    let timestamp = try reader.readString()
    return TickReply(seq: seq, timestamp: timestamp)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeUInt32(seq)
    writer.writeString(timestamp)
  }

  public var encodedSize: Int {
    var size = 0
    size += 4
    size += (4 + timestamp.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "TickReply",
    fqn: "TickReply",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "seq",
          index: 0,
          typeName: "UInt32"
        ),
        BebopFieldReflection(
          name: "timestamp",
          index: 0,
          typeName: "String"
        ),
      ]))
  )
}

public struct LogEntry: BebopRecord, BebopReflectable {
  public let line: String

  enum CodingKeys: String, CodingKey {
    case line
  }

  public init(line: String) {
    self.line = line
  }

  public static func decode(from reader: inout BebopReader) throws -> LogEntry {
    let line = try reader.readString()
    return LogEntry(line: line)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeString(line)
  }

  public var encodedSize: Int {
    var size = 0
    size += (4 + line.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "LogEntry",
    fqn: "LogEntry",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "line",
          index: 0,
          typeName: "String"
        )
      ]))
  )
}

public struct LogSummary: BebopRecord, BebopReflectable {
  public let totalLines: UInt32

  public let preview: String

  enum CodingKeys: String, CodingKey {
    case totalLines
    case preview
  }

  public init(totalLines: UInt32, preview: String) {
    self.totalLines = totalLines
    self.preview = preview
  }

  public static func decode(from reader: inout BebopReader) throws -> LogSummary {
    let totalLines = try reader.readUInt32()
    let preview = try reader.readString()
    return LogSummary(totalLines: totalLines, preview: preview)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeUInt32(totalLines)
    writer.writeString(preview)
  }

  public var encodedSize: Int {
    var size = 0
    size += 4
    size += (4 + preview.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "LogSummary",
    fqn: "LogSummary",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "totalLines",
          index: 0,
          typeName: "UInt32"
        ),
        BebopFieldReflection(
          name: "preview",
          index: 0,
          typeName: "String"
        ),
      ]))
  )
}

/// A greeting service similar to gRPC's helloworld example.
public enum Greeter: BebopServiceDefinition {
  public enum Method: UInt32, BebopServiceMethod, CaseIterable {
    case sayHello = 0x77AF_FF05
    case streamTicks = 0x59C9_211D
    case uploadLogs = 0x1F02_4C8C
    case chat = 0x8671_4DFF

    public var name: String {
      switch self {
      case .sayHello: return "SayHello"
      case .streamTicks: return "StreamTicks"
      case .uploadLogs: return "UploadLogs"
      case .chat: return "Chat"
      }
    }

    public var methodType: MethodType {
      switch self {
      case .sayHello: return MethodType(rawValue: 0)
      case .streamTicks: return MethodType(rawValue: 1)
      case .uploadLogs: return MethodType(rawValue: 2)
      case .chat: return MethodType(rawValue: 3)
      }
    }

    public var requestTypeUrl: String {
      switch self {
      case .sayHello: return "type.bebop.sh/HelloRequest"
      case .streamTicks: return "type.bebop.sh/TickRequest"
      case .uploadLogs: return "type.bebop.sh/LogEntry"
      case .chat: return "type.bebop.sh/HelloRequest"
      }
    }

    public var responseTypeUrl: String {
      switch self {
      case .sayHello: return "type.bebop.sh/HelloReply"
      case .streamTicks: return "type.bebop.sh/TickReply"
      case .uploadLogs: return "type.bebop.sh/LogSummary"
      case .chat: return "type.bebop.sh/HelloReply"
      }
    }
  }

  public static let serviceName = "Greeter"
  public static let serviceInfo = ServiceInfo(
    name: "Greeter",
    methods: [
      MethodInfo(
        name: "SayHello",
        methodId: 0x77AF_FF05,
        methodType: MethodType(rawValue: 0),
        requestTypeUrl: "type.bebop.sh/HelloRequest",
        responseTypeUrl: "type.bebop.sh/HelloReply"
      ),
      MethodInfo(
        name: "StreamTicks",
        methodId: 0x59C9_211D,
        methodType: MethodType(rawValue: 1),
        requestTypeUrl: "type.bebop.sh/TickRequest",
        responseTypeUrl: "type.bebop.sh/TickReply"
      ),
      MethodInfo(
        name: "UploadLogs",
        methodId: 0x1F02_4C8C,
        methodType: MethodType(rawValue: 2),
        requestTypeUrl: "type.bebop.sh/LogEntry",
        responseTypeUrl: "type.bebop.sh/LogSummary"
      ),
      MethodInfo(
        name: "Chat",
        methodId: 0x8671_4DFF,
        methodType: MethodType(rawValue: 3),
        requestTypeUrl: "type.bebop.sh/HelloRequest",
        responseTypeUrl: "type.bebop.sh/HelloReply"
      ),
    ]
  )
  public static func method(for id: UInt32) -> Method? { Method(rawValue: id) }
}

public protocol GreeterHandler: BebopHandler {
  /// Send a greeting and receive a reply.
  func sayHello(
    _ request: HelloRequest,
    context: some CallContext
  ) async throws -> HelloReply

  /// Request a stream of periodic ticks.
  func streamTicks(
    _ request: TickRequest,
    context: some CallContext
  ) async throws -> AsyncThrowingStream<TickReply, Error>

  /// Upload log lines and get a summary.
  func uploadLogs(
    _ requests: AsyncThrowingStream<LogEntry, Error>,
    context: some CallContext
  ) async throws -> LogSummary

  /// Bidirectional chat: send names, receive greetings.
  func chat(
    _ requests: AsyncThrowingStream<HelloRequest, Error>,
    context: some CallContext
  ) async throws -> AsyncThrowingStream<HelloReply, Error>
}

extension BebopRouterBuilder {
  public func register(greeter handler: some GreeterHandler) {
    register(
      Greeter.self,
      unary: { method, context, payload in
        switch method {
        case .sayHello:
          let req = try HelloRequest.decode(from: payload)
          let res = try await handler.sayHello(req, context: context)
          return res.serializedData()
        default: throw BebopRpcError(code: .unimplemented)
        }
      },
      serverStream: { method, context, payload in
        switch method {
        case .streamTicks:
          let req = try TickRequest.decode(from: payload)
          let typed = try await handler.streamTicks(req, context: context)
          return AsyncThrowingStream<[UInt8], Error> { c in
            let task = Task {
              do {
                for try await item in typed {
                  try Task.checkCancellation()
                  c.yield(item.serializedData())
                }
                c.finish()
              } catch {
                c.finish(throwing: error)
              }
            }
            c.onTermination = { _ in task.cancel() }
          }
        default: throw BebopRpcError(code: .unimplemented)
        }
      },
      clientStream: { method, context in
        switch method {
        case .uploadLogs:
          let (stream, continuation) = AsyncThrowingStream.makeStream(of: LogEntry.self)
          let task = Task { try await handler.uploadLogs(stream, context: context) }
          return (
            send: { bytes in
              let req = try LogEntry.decode(from: bytes)
              continuation.yield(req)
            },
            finish: {
              continuation.finish()
              return try await task.value.serializedData()
            }
          )
        default: throw BebopRpcError(code: .unimplemented)
        }
      },
      duplexStream: { method, context in
        switch method {
        case .chat:
          let (stream, continuation) = AsyncThrowingStream.makeStream(of: HelloRequest.self)
          let typedResponses = try await handler.chat(stream, context: context)
          let rawResponses = AsyncThrowingStream<[UInt8], Error> { c in
            let task = Task {
              do {
                for try await item in typedResponses {
                  try Task.checkCancellation()
                  c.yield(item.serializedData())
                }
                c.finish()
              } catch {
                c.finish(throwing: error)
              }
            }
            c.onTermination = { _ in
              task.cancel()
              continuation.finish()
            }
          }
          return (
            send: { bytes in
              let req = try HelloRequest.decode(from: bytes)
              continuation.yield(req)
            },
            finish: { continuation.finish() },
            responses: rawResponses
          )
        default: throw BebopRpcError(code: .unimplemented)
        }
      })
  }
}

public struct GreeterClient<C: BebopChannel>: Sendable {
  public let channel: C

  public init(channel: C) { self.channel = channel }

  /// Send a greeting and receive a reply.
  public func sayHello(
    _ request: HelloRequest,
    options: CallOptions = .default
  ) async throws -> HelloReply {
    let data = try await channel.unary(
      method: 0x77AF_FF05,
      request: request.serializedData(),
      options: options
    )
    return try HelloReply.decode(from: data)
  }

  public func sayHello(
    name: String,
    options: CallOptions = .default
  ) async throws -> HelloReply {
    try await sayHello(HelloRequest(name: name), options: options)
  }

  /// Request a stream of periodic ticks.
  public func streamTicks(
    _ request: TickRequest,
    options: CallOptions = .default
  ) async throws -> AsyncThrowingStream<TickReply, Error> {
    let raw = try await channel.serverStream(
      method: 0x59C9_211D,
      request: request.serializedData(),
      options: options
    )
    return raw.decode(TickReply.self)
  }

  public func streamTicks(
    count: UInt32,
    options: CallOptions = .default
  ) async throws -> AsyncThrowingStream<TickReply, Error> {
    try await streamTicks(TickRequest(count: count), options: options)
  }

  /// Upload log lines and get a summary.
  public func uploadLogs(
    options: CallOptions = .default,
    body: (
      _ send: @Sendable (LogEntry) async throws -> Void
    ) async throws -> Void
  ) async throws -> LogSummary {
    let (rawSend, rawFinish) = try await channel.clientStream(
      method: 0x1F02_4C8C,
      options: options
    )
    try await body({ try await rawSend($0.serializedData()) })
    return try await LogSummary.decode(from: rawFinish())
  }

  /// Bidirectional chat: send names, receive greetings.
  public func chat(
    options: CallOptions = .default,
    body: (
      _ send: @Sendable (HelloRequest) async throws -> Void,
      _ finish: @Sendable () async throws -> Void,
      _ responses: AsyncThrowingStream<HelloReply, Error>
    ) async throws -> Void
  ) async throws {
    let (rawSend, rawFinish, rawResponses) = try await channel.duplexStream(
      method: 0x8671_4DFF,
      options: options
    )
    do {
      try await body(
        { try await rawSend($0.serializedData()) },
        rawFinish,
        rawResponses.decode(HelloReply.self)
      )
    } catch {
      try? await rawFinish()
      throw error
    }
  }
}

public struct Greeter_Batch<C: BebopChannel> {
  public let batch: Batch<C>

  @discardableResult
  public func sayHello(_ request: HelloRequest) -> CallRef<HelloReply> {
    batch.addUnary(methodId: 0x77AF_FF05, request: request)
  }

  @discardableResult
  public func sayHello(name: String) -> CallRef<HelloReply> {
    sayHello(HelloRequest(name: name))
  }

  @discardableResult
  public func sayHello<T: BebopRecord>(forwarding ref: CallRef<T>) -> CallRef<HelloReply> {
    batch.addUnary(methodId: 0x77AF_FF05, forwardingFrom: ref.callId)
  }

  @discardableResult
  public func streamTicks(_ request: TickRequest) -> StreamRef<TickReply> {
    batch.addServerStream(methodId: 0x59C9_211D, request: request)
  }

  @discardableResult
  public func streamTicks(count: UInt32) -> StreamRef<TickReply> {
    streamTicks(TickRequest(count: count))
  }

  @discardableResult
  public func streamTicks<T: BebopRecord>(forwarding ref: CallRef<T>) -> StreamRef<TickReply> {
    batch.addServerStream(methodId: 0x59C9_211D, forwardingFrom: ref.callId)
  }
}

extension Batch {
  public var greeter: Greeter_Batch<Channel> { Greeter_Batch(batch: self) }
}
