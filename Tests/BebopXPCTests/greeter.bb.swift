// Code generated by bebopc-gen-swift. DO NOT EDIT.
// source: Tests/BebopXPCTests/greeter.bop
// bebopc 2026.0.0
// edition 2026
//
// This file requires the Bebop runtime library.
// https://github.com/6over3/bebop
//
// The Bebop compiler and runtime are licensed under the Apache License,
// Version 2.0. You may obtain a copy of the License at:
// https://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 6OVER3 INSTITUTE
// swiftlint:disable all

import SwiftBebop
// @@bebop_insertion_point(imports)

public struct HelloRequest: BebopRecord, BebopReflectable {
    public let name: String

    enum CodingKeys: String, CodingKey {
        case name
    }

    public init(name: String) {
        self.name = name
    }

    public static func decode(from reader: inout BebopReader) throws -> HelloRequest {
        // @@bebop_insertion_point(decode_start:HelloRequest)
        let name = try reader.readString()
        // @@bebop_insertion_point(decode_end:HelloRequest)
        return HelloRequest(name: name)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:HelloRequest)
        writer.writeString(name)
        // @@bebop_insertion_point(encode_end:HelloRequest)
    }

    public var encodedSize: Int {
        var size = 0
        size += (4 + name.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "HelloRequest",
        fqn: "HelloRequest",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "name",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:HelloRequest)
}

public struct HelloReply: BebopRecord, BebopReflectable {
    public let greeting: String

    enum CodingKeys: String, CodingKey {
        case greeting
    }

    public init(greeting: String) {
        self.greeting = greeting
    }

    public static func decode(from reader: inout BebopReader) throws -> HelloReply {
        // @@bebop_insertion_point(decode_start:HelloReply)
        let greeting = try reader.readString()
        // @@bebop_insertion_point(decode_end:HelloReply)
        return HelloReply(greeting: greeting)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:HelloReply)
        writer.writeString(greeting)
        // @@bebop_insertion_point(encode_end:HelloReply)
    }

    public var encodedSize: Int {
        var size = 0
        size += (4 + greeting.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "HelloReply",
        fqn: "HelloReply",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "greeting",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:HelloReply)
}

public struct TickRequest: BebopRecord, BebopReflectable {
    public let count: UInt32

    enum CodingKeys: String, CodingKey {
        case count
    }

    public init(count: UInt32) {
        self.count = count
    }

    public static func decode(from reader: inout BebopReader) throws -> TickRequest {
        // @@bebop_insertion_point(decode_start:TickRequest)
        let count = try reader.readUInt32()
        // @@bebop_insertion_point(decode_end:TickRequest)
        return TickRequest(count: count)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:TickRequest)
        writer.writeUInt32(count)
        // @@bebop_insertion_point(encode_end:TickRequest)
    }

    public var encodedSize: Int { 4 }

    public static let bebopReflection = BebopTypeReflection(
        name: "TickRequest",
        fqn: "TickRequest",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "count",
                    index: 0,
                    typeName: "UInt32"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:TickRequest)
}

public struct TickReply: BebopRecord, BebopReflectable {
    public let seq: UInt32

    public let timestamp: String

    enum CodingKeys: String, CodingKey {
        case seq
        case timestamp
    }

    public init(seq: UInt32, timestamp: String) {
        self.seq = seq
        self.timestamp = timestamp
    }

    public static func decode(from reader: inout BebopReader) throws -> TickReply {
        // @@bebop_insertion_point(decode_start:TickReply)
        let seq = try reader.readUInt32()
        let timestamp = try reader.readString()
        // @@bebop_insertion_point(decode_end:TickReply)
        return TickReply(seq: seq, timestamp: timestamp)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:TickReply)
        writer.writeUInt32(seq)
        writer.writeString(timestamp)
        // @@bebop_insertion_point(encode_end:TickReply)
    }

    public var encodedSize: Int {
        var size = 0
        size += 4
        size += (4 + timestamp.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "TickReply",
        fqn: "TickReply",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "seq",
                    index: 0,
                    typeName: "UInt32"
                ),
                BebopFieldReflection(
                    name: "timestamp",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:TickReply)
}

public struct LogEntry: BebopRecord, BebopReflectable {
    public let line: String

    enum CodingKeys: String, CodingKey {
        case line
    }

    public init(line: String) {
        self.line = line
    }

    public static func decode(from reader: inout BebopReader) throws -> LogEntry {
        // @@bebop_insertion_point(decode_start:LogEntry)
        let line = try reader.readString()
        // @@bebop_insertion_point(decode_end:LogEntry)
        return LogEntry(line: line)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:LogEntry)
        writer.writeString(line)
        // @@bebop_insertion_point(encode_end:LogEntry)
    }

    public var encodedSize: Int {
        var size = 0
        size += (4 + line.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "LogEntry",
        fqn: "LogEntry",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "line",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:LogEntry)
}

public struct LogSummary: BebopRecord, BebopReflectable {
    public let totalLines: UInt32

    public let preview: String

    enum CodingKeys: String, CodingKey {
        case totalLines
        case preview
    }

    public init(totalLines: UInt32, preview: String) {
        self.totalLines = totalLines
        self.preview = preview
    }

    public static func decode(from reader: inout BebopReader) throws -> LogSummary {
        // @@bebop_insertion_point(decode_start:LogSummary)
        let totalLines = try reader.readUInt32()
        let preview = try reader.readString()
        // @@bebop_insertion_point(decode_end:LogSummary)
        return LogSummary(totalLines: totalLines, preview: preview)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:LogSummary)
        writer.writeUInt32(totalLines)
        writer.writeString(preview)
        // @@bebop_insertion_point(encode_end:LogSummary)
    }

    public var encodedSize: Int {
        var size = 0
        size += 4
        size += (4 + preview.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "LogSummary",
        fqn: "LogSummary",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "totalLines",
                    index: 0,
                    typeName: "UInt32"
                ),
                BebopFieldReflection(
                    name: "preview",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:LogSummary)
}

/// A greeting service similar to gRPC's helloworld example.
public enum Greeter: BebopServiceDefinition {
    public enum Method: UInt32, BebopServiceMethod, CaseIterable {
        case sayHello = 0x77AFFF05
        case streamTicks = 0x59C9211D
        case uploadLogs = 0x1F024C8C
        case chat = 0x86714DFF

        public var name: String {
            switch self {
                case .sayHello: return "SayHello"
                case .streamTicks: return "StreamTicks"
                case .uploadLogs: return "UploadLogs"
                case .chat: return "Chat"
            }
        }

        public var methodType: MethodType {
            switch self {
                case .sayHello: return .unary
                case .streamTicks: return .serverStream
                case .uploadLogs: return .clientStream
                case .chat: return .duplexStream
            }
        }

        public var requestTypeUrl: String {
            switch self {
                case .sayHello: return "type.bebop.sh/HelloRequest"
                case .streamTicks: return "type.bebop.sh/TickRequest"
                case .uploadLogs: return "type.bebop.sh/LogEntry"
                case .chat: return "type.bebop.sh/HelloRequest"
            }
        }

        public var responseTypeUrl: String {
            switch self {
                case .sayHello: return "type.bebop.sh/HelloReply"
                case .streamTicks: return "type.bebop.sh/TickReply"
                case .uploadLogs: return "type.bebop.sh/LogSummary"
                case .chat: return "type.bebop.sh/HelloReply"
            }
        }
    }

    public static let serviceName = "Greeter"
    public static let serviceInfo = ServiceInfo(
        name: "Greeter",
        methods: [
            MethodInfo(
                name: "SayHello",
                methodId: 0x77AFFF05,
                methodType: .unary,
                requestTypeUrl: "type.bebop.sh/HelloRequest",
                responseTypeUrl: "type.bebop.sh/HelloReply"
            ),
            MethodInfo(
                name: "StreamTicks",
                methodId: 0x59C9211D,
                methodType: .serverStream,
                requestTypeUrl: "type.bebop.sh/TickRequest",
                responseTypeUrl: "type.bebop.sh/TickReply"
            ),
            MethodInfo(
                name: "UploadLogs",
                methodId: 0x1F024C8C,
                methodType: .clientStream,
                requestTypeUrl: "type.bebop.sh/LogEntry",
                responseTypeUrl: "type.bebop.sh/LogSummary"
            ),
            MethodInfo(
                name: "Chat",
                methodId: 0x86714DFF,
                methodType: .duplexStream,
                requestTypeUrl: "type.bebop.sh/HelloRequest",
                responseTypeUrl: "type.bebop.sh/HelloReply"
            )
        ]
    )
    public static func method(for id: UInt32) -> Method? { Method(rawValue: id) }
    // @@bebop_insertion_point(service_scope:Greeter)
}

public protocol GreeterHandler: BebopHandler {
    /// Send a greeting and receive a reply.
    func sayHello(
        _ request: HelloRequest,
        context: RpcContext
    ) async throws -> HelloReply

    /// Request a stream of periodic ticks.
    func streamTicks(
        _ request: TickRequest,
        context: RpcContext
    ) async throws -> AsyncThrowingStream<TickReply, Error>

    /// Upload log lines and get a summary.
    func uploadLogs(
        _ requests: AsyncThrowingStream<LogEntry, Error>,
        context: RpcContext
    ) async throws -> LogSummary

    /// Bidirectional chat: send names, receive greetings.
    func chat(
        _ requests: AsyncThrowingStream<HelloRequest, Error>,
        context: RpcContext
    ) async throws -> AsyncThrowingStream<HelloReply, Error>
}

extension BebopRouterBuilder {
    public func register(greeter handler: some GreeterHandler) {
        register(Greeter.self, unary: { method, context, payload in
            switch method {
                case .sayHello:
                    let req = try HelloRequest.decode(from: payload)
                    let res = try await handler.sayHello(req, context: context)
                    return res.serializedData()
                default: throw BebopRpcError(code: .unimplemented)
            }
        }, serverStream: { method, context, payload in
            switch method {
                case .streamTicks:
                    let req = try TickRequest.decode(from: payload)
                    let typed = try await handler.streamTicks(req, context: context)
                    return AsyncThrowingStream<StreamElement, Error> { c in
                        let task = Task {
                            do {
                                for try await item in typed {
                                    try Task.checkCancellation()
                                    if let d = context.deadline, d.isPast {
                                        throw BebopRpcError(code: .deadlineExceeded)
                                    }
                                    c.yield(StreamElement(bytes: item.serializedData(), cursor: context.dequeueCursor()))
                                }
                                c.finish()
                            } catch {
                                c.finish(throwing: error)
                            }
                        }
                        c.onTermination = { _ in task.cancel() }
                    }
                default: throw BebopRpcError(code: .unimplemented)
            }
        }, clientStream: { method, context in
            switch method {
                case .uploadLogs:
                    let (stream, continuation) = AsyncThrowingStream.makeStream(of: LogEntry.self)
                    let task = Task {
                        defer { continuation.finish() }
                        return try await handler.uploadLogs(stream, context: context)
                    }
                    return (
                        send: { bytes in
                            try Task.checkCancellation()
                            if let d = context.deadline, d.isPast {
                                throw BebopRpcError(code: .deadlineExceeded)
                            }
                            let req = try LogEntry.decode(from: bytes)
                            if case .terminated = continuation.yield(req) {
                                throw BebopRpcError(code: .cancelled, detail: "stream terminated")
                            }
                        },
                        finish: {
                            continuation.finish()
                            return try await task.value.serializedData()
                        }
                    )
                default: throw BebopRpcError(code: .unimplemented)
            }
        }, duplexStream: { method, context in
            switch method {
                case .chat:
                    let (stream, continuation) = AsyncThrowingStream.makeStream(of: HelloRequest.self)
                    let typedResponses = try await handler.chat(stream, context: context)
                    let rawResponses = AsyncThrowingStream<StreamElement, Error> { c in
                        let task = Task {
                            do {
                                for try await item in typedResponses {
                                    try Task.checkCancellation()
                                    if let d = context.deadline, d.isPast {
                                        throw BebopRpcError(code: .deadlineExceeded)
                                    }
                                    c.yield(StreamElement(bytes: item.serializedData(), cursor: context.dequeueCursor()))
                                }
                                c.finish()
                            } catch {
                                c.finish(throwing: error)
                            }
                        }
                        c.onTermination = { _ in
                            task.cancel()
                            continuation.finish()
                        }
                    }
                    return (
                        send: { bytes in
                            try Task.checkCancellation()
                            if let d = context.deadline, d.isPast {
                                throw BebopRpcError(code: .deadlineExceeded)
                            }
                            let req = try HelloRequest.decode(from: bytes)
                            if case .terminated = continuation.yield(req) {
                                throw BebopRpcError(code: .cancelled, detail: "stream terminated")
                            }
                        },
                        finish: { continuation.finish() },
                        responses: rawResponses
                    )
                default: throw BebopRpcError(code: .unimplemented)
            }
        })
    }
}

public struct GreeterClient<C: BebopChannel>: Sendable {
    public let channel: C

    public init(channel: C) { self.channel = channel }

    /// Send a greeting and receive a reply.
    public func sayHello(
        _ request: HelloRequest,
        context: RpcContext = RpcContext()
    ) async throws -> Response<HelloReply, C.Metadata> {
        try await channel.unary(
            method: 0x77AFFF05,
            request: request.serializedData(),
            context: context
        ).map { try HelloReply.decode(from: $0) }
    }

    public func sayHello(
        name: String,
        context: RpcContext = RpcContext()
    ) async throws -> Response<HelloReply, C.Metadata> {
        try await sayHello(HelloRequest(name: name), context: context)
    }

    /// Request a stream of periodic ticks.
    public func streamTicks(
        _ request: TickRequest,
        context: RpcContext = RpcContext()
    ) async throws -> StreamResponse<TickReply, C.Metadata> {
        try await channel.serverStream(
            method: 0x59C9211D,
            request: request.serializedData(),
            context: context
        ).map { try TickReply.decode(from: $0) }
    }

    public func streamTicks(
        count: UInt32,
        context: RpcContext = RpcContext()
    ) async throws -> StreamResponse<TickReply, C.Metadata> {
        try await streamTicks(TickRequest(count: count), context: context)
    }

    /// Upload log lines and get a summary.
    public func uploadLogs(
        context: RpcContext = RpcContext(),
        body: (
            _ send: @Sendable (LogEntry) async throws -> Void
        ) async throws -> Void
    ) async throws -> Response<LogSummary, C.Metadata> {
        let (rawSend, rawFinish) = try await channel.clientStream(
            method: 0x1F024C8C,
            context: context
        )
        try await body({ try await rawSend($0.serializedData()) })
        return try await rawFinish().map { try LogSummary.decode(from: $0) }
    }

    /// Bidirectional chat: send names, receive greetings.
    public func chat(
        context: RpcContext = RpcContext(),
        body: (
            _ send: @Sendable (HelloRequest) async throws -> Void,
            _ finish: @Sendable () async throws -> Void,
            _ responses: StreamResponse<HelloReply, C.Metadata>
        ) async throws -> Void
    ) async throws {
        let (rawSend, rawFinish, rawResponses) = try await channel.duplexStream(
            method: 0x86714DFF,
            context: context
        )
        do {
            try await body(
                { try await rawSend($0.serializedData()) },
                rawFinish,
                rawResponses.map { try HelloReply.decode(from: $0) }
            )
        } catch {
            try? await rawFinish()
            throw error
        }
    }
}

public struct Greeter_Batch<C: BebopChannel> {
    public let batch: Batch<C>

    @discardableResult
    public func sayHello(_ request: HelloRequest) -> CallRef<HelloReply> {
        batch.addUnary(methodId: 0x77AFFF05, request: request)
    }

    @discardableResult
    public func sayHello(name: String) -> CallRef<HelloReply> {
        sayHello(HelloRequest(name: name))
    }

    @discardableResult
    public func sayHello<T: BebopRecord>(forwarding ref: CallRef<T>) -> CallRef<HelloReply> {
        batch.addUnary(methodId: 0x77AFFF05, forwardingFrom: ref.callId)
    }

    @discardableResult
    public func streamTicks(_ request: TickRequest) -> StreamRef<TickReply> {
        batch.addServerStream(methodId: 0x59C9211D, request: request)
    }

    @discardableResult
    public func streamTicks(count: UInt32) -> StreamRef<TickReply> {
        streamTicks(TickRequest(count: count))
    }

    @discardableResult
    public func streamTicks<T: BebopRecord>(forwarding ref: CallRef<T>) -> StreamRef<TickReply> {
        batch.addServerStream(methodId: 0x59C9211D, forwardingFrom: ref.callId)
    }
}

extension Batch {
    public var greeter: Greeter_Batch<Channel> { Greeter_Batch(batch: self) }
}

public struct Greeter_Dispatch<C: BebopChannel> {
    public let dispatcher: FutureDispatcher<C>

    public func sayHello(
        _ request: HelloRequest,
        idempotencyKey: BebopUUID? = nil,
        context: RpcContext = RpcContext()
    ) async throws -> BebopFuture<HelloReply> {
        try await dispatcher.dispatch(
            methodId: 0x77AFFF05,
            request: request,
            idempotencyKey: idempotencyKey,
            context: context)
    }

    public func sayHello(
        name: String,
        idempotencyKey: BebopUUID? = nil,
        context: RpcContext = RpcContext()
    ) async throws -> BebopFuture<HelloReply> {
        try await sayHello(HelloRequest(name: name), idempotencyKey: idempotencyKey, context: context)
    }
}

extension FutureDispatcher {
    public var greeter: Greeter_Dispatch<Channel> { Greeter_Dispatch(dispatcher: self) }
}

// @@bebop_insertion_point(eof)
