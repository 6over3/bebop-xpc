// Code generated by bebopc-gen-swift. DO NOT EDIT.
// source: Examples/ExifService/exif.bop
// bebopc 2026.0.0
// edition 2026
//
// This file requires the Bebop runtime library.
// https://github.com/6over3/bebop
//
// The Bebop compiler and runtime are licensed under the Apache License,
// Version 2.0. You may obtain a copy of the License at:
// https://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 6OVER3 INSTITUTE
// swiftlint:disable all

import SwiftBebop
// @@bebop_insertion_point(imports)

public struct ReadRequest: BebopRecord, BebopReflectable {
    public let path: String

    enum CodingKeys: String, CodingKey {
        case path
    }

    public init(path: String) {
        self.path = path
    }

    public static func decode(from reader: inout BebopReader) throws -> ReadRequest {
        // @@bebop_insertion_point(decode_start:ReadRequest)
        let path = try reader.readString()
        // @@bebop_insertion_point(decode_end:ReadRequest)
        return ReadRequest(path: path)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:ReadRequest)
        writer.writeString(path)
        // @@bebop_insertion_point(encode_end:ReadRequest)
    }

    public var encodedSize: Int {
        var size = 0
        size += (4 + path.utf8.count + 1)
        return size
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "ReadRequest",
        fqn: "ReadRequest",
        kind: .struct,
        detail: .struct(
            StructReflection(fields: [
                BebopFieldReflection(
                    name: "path",
                    index: 0,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(struct_scope:ReadRequest)
}

public final class ReadResponse: BebopRecord, BebopReflectable, @unchecked Sendable {
    public var path: String?

    public var json: String?

    public var error: String?

    public init(path: String? = nil, json: String? = nil, error: String? = nil) {
        self.path = path
        self.json = json
        self.error = error
    }

    public static func == (lhs: ReadResponse, rhs: ReadResponse) -> Bool {
        return lhs.path == rhs.path && lhs.json == rhs.json && lhs.error == rhs.error
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(json)
        hasher.combine(error)
    }

    public static func decode(from reader: inout BebopReader) throws -> ReadResponse {
        // @@bebop_insertion_point(decode_start:ReadResponse)
        let length = try reader.readMessageLength()
        let end = reader.position + Int(length)
        var path: String? = nil
        var json: String? = nil
        var error: String? = nil
        while reader.position < end {
            let tag = try reader.readTag()
            if tag == 0 { break }
            switch tag {
            case 1:
                path = try reader.readString()
            case 2:
                json = try reader.readString()
            case 3:
                error = try reader.readString()
            default:
                try reader.skip(end - reader.position)
            }
        }
        // @@bebop_insertion_point(decode_end:ReadResponse)
        return ReadResponse(path: path, json: json, error: error)
    }

    public func encode(to writer: inout BebopWriter) {
        // @@bebop_insertion_point(encode_start:ReadResponse)
        let pos = writer.reserveMessageLength()
        if let _v = path {
            writer.writeTag(1)
            writer.writeString(_v)
        }
        if let _v = json {
            writer.writeTag(2)
            writer.writeString(_v)
        }
        if let _v = error {
            writer.writeTag(3)
            writer.writeString(_v)
        }
        writer.writeEndMarker()
        writer.fillMessageLength(at: pos)
        // @@bebop_insertion_point(encode_end:ReadResponse)
    }

    public var encodedSize: Int {
        var size = 5
        if let _v = path { size += 1 + (4 + _v.utf8.count + 1) }
        if let _v = json { size += 1 + (4 + _v.utf8.count + 1) }
        if let _v = error { size += 1 + (4 + _v.utf8.count + 1) }
        return size
    }

    enum CodingKeys: String, CodingKey {
        case path
        case json
        case error
    }

    public static let bebopReflection = BebopTypeReflection(
        name: "ReadResponse",
        fqn: "ReadResponse",
        kind: .message,
        detail: .message(
            MessageReflection(fields: [
                BebopFieldReflection(
                    name: "path",
                    index: 1,
                    typeName: "String"
                ),
                BebopFieldReflection(
                    name: "json",
                    index: 2,
                    typeName: "String"
                ),
                BebopFieldReflection(
                    name: "error",
                    index: 3,
                    typeName: "String"
                )
            ])
        )
    )

    // @@bebop_insertion_point(message_scope:ReadResponse)
}

public enum ExifService: BebopServiceDefinition {
    public enum Method: UInt32, BebopServiceMethod, CaseIterable {
        case read = 0xAFE77597

        public var name: String {
            switch self {
                case .read: return "Read"
            }
        }

        public var methodType: MethodType {
            switch self {
                case .read: return .unary
            }
        }

        public var requestTypeUrl: String {
            switch self {
                case .read: return "type.bebop.sh/ReadRequest"
            }
        }

        public var responseTypeUrl: String {
            switch self {
                case .read: return "type.bebop.sh/ReadResponse"
            }
        }
    }

    public static let serviceName = "ExifService"
    public static let serviceInfo = ServiceInfo(
        name: "ExifService",
        methods: [
            MethodInfo(
                name: "Read",
                methodId: 0xAFE77597,
                methodType: .unary,
                requestTypeUrl: "type.bebop.sh/ReadRequest",
                responseTypeUrl: "type.bebop.sh/ReadResponse"
            )
        ]
    )
    public static func method(for id: UInt32) -> Method? { Method(rawValue: id) }
    // @@bebop_insertion_point(service_scope:ExifService)
}

public protocol ExifServiceHandler: BebopHandler {
    func read(
        _ request: ReadRequest,
        context: RpcContext
    ) async throws -> ReadResponse
}

extension BebopRouterBuilder {
    public func register(exifService handler: some ExifServiceHandler) {
        register(ExifService.self, unary: { method, context, payload in
            switch method {
                case .read:
                    let req = try ReadRequest.decode(from: payload)
                    let res = try await handler.read(req, context: context)
                    return res.serializedData()
                default: throw BebopRpcError(code: .unimplemented)
            }
        }, serverStream: { method, context, payload in
            throw BebopRpcError(code: .unimplemented)
        }, clientStream: { method, context in
            throw BebopRpcError(code: .unimplemented)
        }, duplexStream: { method, context in
            throw BebopRpcError(code: .unimplemented)
        })
    }
}

public struct ExifServiceClient<C: BebopChannel>: Sendable {
    public let channel: C

    public init(channel: C) { self.channel = channel }

    public func read(
        _ request: ReadRequest,
        context: RpcContext = RpcContext()
    ) async throws -> Response<ReadResponse, C.Metadata> {
        try await channel.unary(
            method: 0xAFE77597,
            request: request.serializedData(),
            context: context
        ).map { try ReadResponse.decode(from: $0) }
    }

    public func read(
        path: String,
        context: RpcContext = RpcContext()
    ) async throws -> Response<ReadResponse, C.Metadata> {
        try await read(ReadRequest(path: path), context: context)
    }
}

public struct ExifService_Batch<C: BebopChannel> {
    public let batch: Batch<C>

    @discardableResult
    public func read(_ request: ReadRequest) -> CallRef<ReadResponse> {
        batch.addUnary(methodId: 0xAFE77597, request: request)
    }

    @discardableResult
    public func read(path: String) -> CallRef<ReadResponse> {
        read(ReadRequest(path: path))
    }

    @discardableResult
    public func read<T: BebopRecord>(forwarding ref: CallRef<T>) -> CallRef<ReadResponse> {
        batch.addUnary(methodId: 0xAFE77597, forwardingFrom: ref.callId)
    }
}

extension Batch {
    public var exifService: ExifService_Batch<Channel> { ExifService_Batch(batch: self) }
}

public struct ExifService_Dispatch<C: BebopChannel> {
    public let dispatcher: FutureDispatcher<C>

    public func read(
        _ request: ReadRequest,
        idempotencyKey: BebopUUID? = nil,
        context: RpcContext = RpcContext()
    ) async throws -> BebopFuture<ReadResponse> {
        try await dispatcher.dispatch(
            methodId: 0xAFE77597,
            request: request,
            idempotencyKey: idempotencyKey,
            context: context)
    }

    public func read(
        path: String,
        idempotencyKey: BebopUUID? = nil,
        context: RpcContext = RpcContext()
    ) async throws -> BebopFuture<ReadResponse> {
        try await read(ReadRequest(path: path), idempotencyKey: idempotencyKey, context: context)
    }
}

extension FutureDispatcher {
    public var exifService: ExifService_Dispatch<Channel> { ExifService_Dispatch(dispatcher: self) }
}

// @@bebop_insertion_point(eof)
