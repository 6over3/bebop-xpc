// Auto-generated by bebopc-gen-swift. Do not edit.
// swiftlint:disable all
import SwiftBebop

public struct ReadRequest: BebopRecord, BebopReflectable {
  public let path: String

  enum CodingKeys: String, CodingKey {
    case path
  }

  public init(path: String) {
    self.path = path
  }

  public static func decode(from reader: inout BebopReader) throws -> ReadRequest {
    let path = try reader.readString()
    return ReadRequest(path: path)
  }

  public func encode(to writer: inout BebopWriter) {
    writer.writeString(path)
  }

  public var encodedSize: Int {
    var size = 0
    size += (4 + path.utf8.count + 1)
    return size
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "ReadRequest",
    fqn: "ReadRequest",
    kind: .struct,
    detail: .struct(
      StructReflection(fields: [
        BebopFieldReflection(
          name: "path",
          index: 0,
          typeName: "String"
        )
      ]))
  )
}

public final class ReadResponse: BebopRecord, BebopReflectable, @unchecked Sendable {
  public var path: String?

  public var json: String?

  public var error: String?

  public init(path: String? = nil, json: String? = nil, error: String? = nil) {
    self.path = path
    self.json = json
    self.error = error
  }

  public static func == (lhs: ReadResponse, rhs: ReadResponse) -> Bool {
    return lhs.path == rhs.path && lhs.json == rhs.json && lhs.error == rhs.error
  }

  public func hash(into hasher: inout Hasher) {
    hasher.combine(path)
    hasher.combine(json)
    hasher.combine(error)
  }

  public static func decode(from reader: inout BebopReader) throws -> ReadResponse {
    let length = try reader.readMessageLength()
    let end = reader.position + Int(length)
    var path: String? = nil
    var json: String? = nil
    var error: String? = nil
    while reader.position < end {
      let tag = try reader.readTag()
      if tag == 0 { break }
      switch tag {
      case 1:
        path = try reader.readString()
      case 2:
        json = try reader.readString()
      case 3:
        error = try reader.readString()
      default:
        try reader.skip(end - reader.position)
      }
    }
    return ReadResponse(path: path, json: json, error: error)
  }

  public func encode(to writer: inout BebopWriter) {
    let pos = writer.reserveMessageLength()
    if let _v = path {
      writer.writeTag(1)
      writer.writeString(_v)
    }
    if let _v = json {
      writer.writeTag(2)
      writer.writeString(_v)
    }
    if let _v = error {
      writer.writeTag(3)
      writer.writeString(_v)
    }
    writer.writeEndMarker()
    writer.fillMessageLength(at: pos)
  }

  public var encodedSize: Int {
    var size = 5
    if let _v = path { size += 1 + (4 + _v.utf8.count + 1) }
    if let _v = json { size += 1 + (4 + _v.utf8.count + 1) }
    if let _v = error { size += 1 + (4 + _v.utf8.count + 1) }
    return size
  }

  enum CodingKeys: String, CodingKey {
    case path
    case json
    case error
  }

  public static let bebopReflection = BebopTypeReflection(
    name: "ReadResponse",
    fqn: "ReadResponse",
    kind: .message,
    detail: .message(
      MessageReflection(fields: [
        BebopFieldReflection(
          name: "path",
          index: 1,
          typeName: "String"
        ),
        BebopFieldReflection(
          name: "json",
          index: 2,
          typeName: "String"
        ),
        BebopFieldReflection(
          name: "error",
          index: 3,
          typeName: "String"
        ),
      ]))
  )
}

public enum ExifService: BebopServiceDefinition {
  public enum Method: UInt32, BebopServiceMethod, CaseIterable {
    case read = 0xAFE7_7597

    public var name: String {
      switch self {
      case .read: return "Read"
      }
    }

    public var methodType: MethodType {
      switch self {
      case .read: return MethodType(rawValue: 0)
      }
    }

    public var requestTypeUrl: String {
      switch self {
      case .read: return "type.bebop.sh/ReadRequest"
      }
    }

    public var responseTypeUrl: String {
      switch self {
      case .read: return "type.bebop.sh/ReadResponse"
      }
    }
  }

  public static let serviceName = "ExifService"
  public static let serviceInfo = ServiceInfo(
    name: "ExifService",
    methods: [
      MethodInfo(
        name: "Read",
        methodId: 0xAFE7_7597,
        methodType: MethodType(rawValue: 0),
        requestTypeUrl: "type.bebop.sh/ReadRequest",
        responseTypeUrl: "type.bebop.sh/ReadResponse"
      )
    ]
  )
  public static func method(for id: UInt32) -> Method? { Method(rawValue: id) }
}

public protocol ExifServiceHandler: BebopHandler {
  func read(
    _ request: ReadRequest,
    context: some CallContext
  ) async throws -> ReadResponse
}

extension BebopRouterBuilder {
  public func register(exifService handler: some ExifServiceHandler) {
    register(
      ExifService.self,
      unary: { method, context, payload in
        switch method {
        case .read:
          let req = try ReadRequest.decode(from: payload)
          let res = try await handler.read(req, context: context)
          return res.serializedData()
        default: throw BebopRpcError(code: .unimplemented)
        }
      },
      serverStream: { method, context, payload in
        throw BebopRpcError(code: .unimplemented)
      },
      clientStream: { method, context in
        throw BebopRpcError(code: .unimplemented)
      },
      duplexStream: { method, context in
        throw BebopRpcError(code: .unimplemented)
      })
  }
}

public struct ExifServiceClient<C: BebopChannel>: Sendable {
  public let channel: C

  public init(channel: C) { self.channel = channel }

  public func read(
    _ request: ReadRequest,
    options: CallOptions = .default
  ) async throws -> Reply<ReadResponse, C.Metadata> {
    try await channel.unary(
      method: 0xAFE7_7597,
      request: request.serializedData(),
      options: options
    ).map { try ReadResponse.decode(from: $0) }
  }

  public func read(
    path: String,
    options: CallOptions = .default
  ) async throws -> Reply<ReadResponse, C.Metadata> {
    try await read(ReadRequest(path: path), options: options)
  }
}

public struct ExifService_Batch<C: BebopChannel> {
  public let batch: Batch<C>

  @discardableResult
  public func read(_ request: ReadRequest) -> CallRef<ReadResponse> {
    batch.addUnary(methodId: 0xAFE7_7597, request: request)
  }

  @discardableResult
  public func read(path: String) -> CallRef<ReadResponse> {
    read(ReadRequest(path: path))
  }

  @discardableResult
  public func read<T: BebopRecord>(forwarding ref: CallRef<T>) -> CallRef<ReadResponse> {
    batch.addUnary(methodId: 0xAFE7_7597, forwardingFrom: ref.callId)
  }
}

extension Batch {
  public var exifService: ExifService_Batch<Channel> { ExifService_Batch(batch: self) }
}
